\section{IoT Communication protocols}


\begin{table}[h!]
\scriptsize
	\begin{tabular}{l|l|l|l|l|l|l|l}
	\bf{Application protocol}& DDS                                     & CoAP                              & AMQP                              & MQTT                                & MQTT-SN & XMPP & HTTP\\\hline
	\bf{Service discovery}   & \multicolumn{3}{c}{mDNS}                & \multicolumn{4}{c}{DNS-SD}                                                                                                         \\
	\bf{Transport}           & \multicolumn{7}{c}{UDP/TCP}                                                    \\
	Network                  & \multicolumn{2}{c}{IPv6 RPL}            & \multicolumn{5}{c}{IPv4/IPv6}                            \\\hline
	\                        & \multicolumn{2}{c}{6LowPan}             & \multicolumn{4}{c}{RFC 2464}                & RFC 5072   \\\hline
	MAC                      & \multicolumn{2}{c}{IEEE 802.15.4}       & \multicolumn{2}{c}{IEEE 802.11 (Wi-Fi)} & \multicolumn{2}{c}{IEEE 802.3 (Ethernet)} & 2G, 3G, LTE\\\hline
	\                        & \multicolumn{2}{c}{2.4GHz, 915, 868MHz} & \multicolumn{2}{c}{2.4, 5GHz}           &         &              &            \\\hline
	\                        & \multicolumn{2}{c}{DSS, FSK, OFDM }     & \multicolumn{2}{c}{CSMA/CA}             & CUTP, FO               &            \\\hline
	\end{tabular}
	\caption{\label{tab:Table} Standardization efforts that support the IoT}
\end{table}


\subsection{Application}

\subsubsection{LwM2M}
\subsubsection{CBOR}
\subsubsection{DTLS}
\subsubsection{OSCOAP}

\subsubsection{COAP (COnstrained Application Protocol)}

The Constrained Application Protocol (CoAP) is a specialized web transfer protocol for use with constrained nodes and constrained networks in the Internet of Things.
More detailed information about the protocol is given in the Contiki OS CoAP section.

\paragraph{Overview}
Like HTTP,
	CoAP is a document transfer protocol.
Unlike HTTP,
	CoAP is designed for the needs of constrained devices.
The packets are much smaller than HTTP TCP flows.
Packets are simple to generate and can be parsed in place without consuming extra RAM in constrained devices.
CoAP runs over UDP,
	not TCP.
Clients and servers communicate through connectionless datagrams.
Retries and reordering are implemented in the application stack.
It follows a client/server model.
Clients make requests to servers,
	servers send back responses.
Clients may GET,
	PUT,
	POST and DELETE resources.
CoAP implements the REST model from HTTP,
	with the primitives GET,
	POST,
	PUT and DELETE.

\paragraph{Coap Methods}
CoAP extends the HTTP request model with the ability to observe a resource.
When the observe flag is set on a CoAP GET request,
	the server may continue to reply after the initial document has been transferred. This allows servers to stream state
	changes to clients as they occur. Either end may cancel the observation.
	CoAP defines a standard mechanism for resource discovery. Servers provide a list
	of their resources (along with metadata about them) at /.well-known/core. These links
	are in the application/link-format media type and allow a client to discover what
	resources are provided and what media types they are.

\paragraph{Coap Transactions}

\paragraph{Coap Messages}
The CoAP message structure is designed to be simpler than HTTP,
	for reduced transmission data.
Each field responds to a specific purpose.



\begin{itemize}
	\item Constrained Application Protocol
	\item The IETF Constrained RESTful Environments
	\item CoAP is bound to UDP
%	\item Enable devices with low resources to use RESTful interactions
	\item CoAP can be divided into two sub-layers
		\begin{itemize}
			\item messaging sub-layer
			\item request/response sub-layer
			\begin{itemize}
				\item[a)] Confirmable. 
				\item[b)] Non-confirmable. 
				\item[c)] Piggybacked responses. 
				\item[d)] Separate response
			\end{itemize}
		\end{itemize}
	\item CoAP, as in HTTP, uses methods such as:
	\begin{itemize}
		\item GET, PUT, POST and DELETE to 
		\item Achieve, Create, Retrieve, Update and Delete
	\end{itemize}
	\begin{itemize}
		\item Ex: the GET method can be used by a server to inquire the client’s temperature
	\end{itemize}
\end{itemize}
	
\subsubsection{MQTT}
\begin{itemize}
	\item Message Queue Telemetry Transport
	\item Andy Stanford-Clark of IBM and Arlen Nipper of Arcom
		\begin{itemize}
			\item Standardized in 2013 at OASIS
		\end{itemize}
	\item MQTT uses the publish/subscribe pattern to provide transition flexibility and simplicity of implementation
	\item MQTT is built on top of the TCP protocol
	\item MQTT delivers messages through three levels of QoS
	\item Specifications
		\begin{itemize}
			\item MQTT v3.1 and MQTT-SN (MQTT-S or V1.2)
			\item MQTT v3.1 adds broker support for indexing topic names
		\end{itemize}
	\item The publisher acts as a generator of interesting data.
\end{itemize}

\subsubsection{XMPP}

\begin{itemize}
	\item Extensible Messaging and Presence Protocol
	\item Developed by the Jabber open source community
	\item An IETF instant messaging standard used for:
	\begin{itemize}
		\item multi-party chatting, voice and telepresence
	\end{itemize}
	\item Connects a client to a server using a XML stanzas
	\item An XML stanza is divided into 3 components:
	\begin{itemize}
		\item message: fills the subject and body fields
		\item presence: notifies customers of status updates
		\item iq (info/query): pairs message senders and receivers
	\end{itemize}
	\item Message stanzas identify:
	\begin{itemize}
		\item the source (from) and destination (to) addresses
		\item types, and IDs of XMPP entities
	\end{itemize}
\end{itemize}

\subsubsection{AMQP}

\begin{itemize}
	\item Advanced Message Queuing Protocol
	\item Communications are handled by two main components
	\begin{itemize}
		\item exchanges: route the messages to appropriate queues.
		\item message queues: Messages can be stored in message queues and then be sent to receivers
	\end{itemize}
	\item It also supports the publish/subscribe communications.
	\item It defines a layer of messaging on top of its transport layer.
	\item AMQP defines two types of messages
	\begin{itemize}
		\item bare massages: supplied by the sender
		\item annotated messages: seen at the receiver
	\end{itemize}
	\item The header in this format conveys the delivery parameters:
	\begin{itemize}
		\item durability, priority, time to live, first acquirer \& delivery count.
	\end{itemize}
	\item AMQP frame format
	\begin{itemize}
		\item[Size] the frame size.
		\item[DOFF] the position of the body inside the frame.
		\item[Type] the format and purpose of the frame.
		\begin{itemize}
			\item Ex: 0x00 show that the frame is an AMQP frame
			\item Ex: 0x01 represents a SASL frame.
		\end{itemize}
	\end{itemize}
\end{itemize}

\subsubsection{DDS}

\begin{itemize}
	\item Data Distribution Service
	\item Developed by Object Management Group (OMG)
	\item Supports 23 QoS policies:
	\begin{itemize}
		\item like security, urgency, priority, durability, reliability, etc
	\end{itemize}
	\item Relies on a broker-less architecture
	\begin{itemize}
		\item uses multicasting to bring excellent Quality of Service
		\item real-time constraints
	\end{itemize}
	\item DDS architecture defines two layers:
	\begin{itemize}
		\item[DLRL] Data-Local Reconstruction Layer
		\begin{itemize}
			\item serves as the interface to the DCPS functionalities
		\end{itemize}
		\item[DCPS] Data-Centric Publish/Subscribe
		\begin{itemize}
			\item delivering the information to the subscribers
		\end{itemize}
	\end{itemize}
	\item 5 entities are involved with the data flow in the DCPS layer:
	\begin{itemize}
		\item Publisher:disseminates data
		\item DataWriter: used by app to interact with the publisher
		\item Subscriber: receives published data and delivers them to app
		\item DataReader: employed by Subscriber to access received data
		\item Topic: relate DataWriters to DataReaders
	\end{itemize}
\end{itemize}
\begin{itemize}
	\item No need for manual reconfiguration or extra administration
	\item It is able to run without infrastructure
	\item It is able to continue working if failure happens.
	\item It inquires names by sending an IP multicast message to all the nodes in the local domain
	\begin{itemize}
		\item Clients asks devices that have the given name to reply back
		\item the target machine receives its name and multicasts its IP @
		\item Devices update their cache with the given name and IP @
	\end{itemize}
\end{itemize}

\subsubsection{mDNS}

\begin{itemize}
	\item Requires zero configuration aids to connect machine
	\item It uses mDNS to send DNS packets to specific multicast addresses through UDP
	\item There are two main steps to process Service Discovery:
	\begin{itemize}
		\item finding host names of required services such as printers
		\item pairing IP addresses with their host names using mDNS
	\end{itemize}
	\item Advantages
	\begin{itemize}
		\item IoT needs an architecture without dependency on a configuration mechanism
		\item smart devices can join the platform or leave it without affecting the behavior of the whole system
	\end{itemize}
	\item Drawbacks
	\begin{itemize}
		\item Need for caching DNS entries
	\end{itemize}
\end{itemize}


\begin{table}
\scriptsize
	\begin{tabulary}{\columnwidth}{C|C|C|C|C|C|C|C}
		\textbf{Application protocol} & RestFull & Transport & Publish/Subscribe & Request/Response & Security & QoS & Header size (Byte)\\\hline
		\textbf{COAP}                 & \ok      & UDP       & \ok               & \ok              & DTLS     & \ok & 4           \\\hline
		\textbf{MQTT}                 & \ko      & TCP       & \ok               & \ko              & SSL      & \ok & 2           \\\hline
		\textbf{MQTT-SN}              & \ko      & TCP       & \ok               & \ko              & SSL      & \ok & 2           \\\hline
		\textbf{XMPP}                 & \ko      & TCP       & \ok               & \ok              & SSL      & \ko & -           \\\hline
		\textbf{AMQP}                 & \ko      & TCP       & \ok               & \ko              & SSL      & \ok & 8           \\\hline
		\textbf{DDS}                  & \ko      & UDP TCP   & \ok               & \ko              & SSL DTLS & \ok & -           \\\hline
		\textbf{HTTP}                 & \ok      & TCP       & \ko               & \ok              & SSL      & \ko & -           \\
	\end{tabulary}
	\caption{\label{tab:protocolsComparisoniu} Application protocols comparison}
\end{table}

\subsection{Network}
%\changefontsizes{pt}


\subsubsection{6TiSCH}
\subsubsection{OLSRv2}
\subsubsection{AODVv2}
\subsubsection{LoRaWAN}


\subsubsection{ROHC}
\subsubsection{IPHC}
\subsubsection{SCHC}

\subsubsection{NHC}
\subsubsection{ROLL}

\subsubsection{RPL}
RPL is a Distance Vector IPv6 routing protocol for LLNs that specifies how to build a Destination Oriented Directed Acyclic Graph (DODAG) using an objective function and a set of metrics/constraints.
The objective function operates on a combination of metrics and constraints to compute the ‘best’ path.

An RPL Instance consists of multiple Destination Oriented Directed Acyclic Graphs (DODAGs).
Traffic moves either up towards the DODAG root or down towards the DODAG leafs.
The graph building process starts at the root or LBR (LowPAN Border Router).
There could be multiple roots configured in the system.
The RPL routing protocol specifies a set of ICMPv6 control messages to exchange graph related information.
These messages are called DIS (DODAG Information Solicitation),
	DIO (DODAG Information Object) and DAO (DODAG Destination Advertisement Object).
The root starts advertising the information about the graph using the DIO message.
The nodes in the listening vicinity (neighbouring nodes) of the root will receive and process DIO messages potentially from multiple nodes and makes a decision based on certain rules (according to the objective function,
	DAG characteristics,
	advertised path cost and potentially local policy) whether to join the graph or not.
Once the node has joined a graph it has a route toward the graph (DODAG) root.
The graph root is termed as the ‘parent’ of the node.
The node computes the ‘rank’ of itself within the graph,
	which indicates the “coordinates” of the node in the graph hierarchy.
If configured to act as a router,
	it starts advertising the graph information with the new information to its neighbouring peers.
If the node is a “leaf node”,
	it simply joins the graph and does not send any DIO message.
The neighbouring peers will repeat this process and do parent selection,
	route addition and graph information advertisement using DIO messages.
This rippling effect builds the graph edges out from the root to the leaf nodes where the process terminates.
In this formation each node of the graph has a routing entry towards its parent (or multiple parents depending on the objective function) in a hop-by-hop fashion and the leaf nodes can send a data packet all the way to root of the graph by just forwarding the packet to its immediate parent.
This model represents a MP2P (Multipoint-to-point) forwarding model where each node of the graph has reach-ability toward the graph root.
This is also referred to as UPWARD routing.
Each node in the graph has a ‘rank’ that is relative and represents an increasing coordinate of the relative position of the node with respect to the root in graph topology.
The notion of “rank” is used by RPL for various purposes including loop avoidance.
The MP2P flow of traffic is called the ‘up’ direction in the DODAG.


The DIS message is used by the nodes to proactively solicit graph information (via DIO) from the neighbouring nodes should it become active in a stable graph environment using the ‘poll’ or ‘pull’ model of retrieving graph information or in other conditions.
Similar to MP2P or ‘up’ direction of traffic,
	which flows from the leaf towards the root there is a need for traffic to flow in the opposite or ‘down’ direction.
This traffic may originate from outside the LLN network,
	at the root or at any intermediate nodes and destined to a (leaf) node.
This requires a routing state to be built at every node and a mechanism to populate these routes.
This is accomplished by the DAO (Destination Advertisement Object) message.
DAO messages are used to advertise prefix reachability towards the leaf nodes in support of the ‘down’ traffic.
These messages carry prefix information,
	valid lifetime and other information about the distance of the prefix.
As each node joins the graph it will send DAO message to its parent set.
Alternately,
	a node or root can poll the sub-dag for DAO message through an indication in the DIO message.
As each node receives the DAO message,
	it processes the prefix information and adds a routing entry in the routing table.
It optionally aggregates the prefix information received from various nodes in the subdag and sends a DAO message to its parent set.
This process continues until the prefix information reaches the root and a complete path to the prefix is setup.
Note that this mode is called the “storing” mode of operation where intermediate nodes have available memory to store routing tables.
RPL also supports another mode called “non-storing” mode where intermediate node do not store any routes.


\subsubsection{6LowPAN}

6LoWPAN is a networking technology or adaptation layer that allows IPv6 packets to be carried efficiently within a small link layer frame,
	over IEEE 802.15.4 based networks.
As the full name implies,
	“IPv6 over Low-Power Wireless Personal Area Networks”,
	it is a protocol for connecting wireless low power networks using IPv6.

As the full name implies,
	“IPv6 over Low-Power Wireless Personal Area Networks”,
	it is a protocol for connecting wireless low power networks using IPv6.

\paragraph{Characteristics}

	\begin{itemize}
		\item Compression of IPv6 and UDP/ICMP headers
		\item Fragmentation / reassembly of IPv6 packets
		\item Mesh addressing
		\item Stateless auto configuration
		\item 
	\end{itemize}
	
\paragraph{Encapsulation Header format}
All LowPAN encapsulated datagrams are prefixed by an encapsulation header stack.
Each header in the stack starts with a header type field followed by zero or more header fields.

\paragraph{Fragment Header}
The fragment header is used when the payload is too large to fit in a single IEEE 802.15.4 frame.
The Fragment header is analogous to the IEEE 1394 Fragment header and includes three fields:
	Datagram Size,
	Datagram Tag,
	and Datagram Offset.
Datagram Size identifies the total size of the unfragmented payload and is included with every fragment to simplify buffer allocation at the receiver when fragments arrive out-oforder.
Datagram Tag identifies the set of fragments that correspond to a given payload and is used to match up fragments of the same payload.
Datagram Offset identifies the fragment’s offset within the unfragmented payload and is in units of 8-byte chunks.

\paragraph{Mesh addressing header}

The Mesh Addressing header is used to forward 6LoWPAN payloads over multiple radio hops and support layer-two forwarding.
The mesh addressing header includes three fields:
	Hop Limit,
	Source Address,
	and Destination Address.
The Hop Limit field is analogous to the IPv6 Hop Limit and limits the number of hops for forwarding.
The Hop Limit field is decremented by each forwarding node,
	and if decremented to zero the frame is dropped.
The source and destination addresses indicate the end-points of an IP hop.
Both addresses are IEEE 802.15.4 link addresses and may carry either a short or extended address.

\paragraph{Header compression (RFC4944)}

RFC 4944 defines HC1,
	a stateless compression scheme optimized for link-local IPv6 communication.
HC1 is identified by an encoding byte following the Compressed IPv6 dispatch header,
	and it operates on fields in the upper-layer headers. 6LoWPAN elides some fields by assuming commonly used values.
For example,
	it compresses the 64-bit network prefix for both source and destination addresses to a single bit each when they carry the well-known link-local prefix. 6LoWPAN compresses the Next Header field to two bits whenever the packet uses UDP,
	TCP,
	or ICMPv6.
Furthermore, 6LoWPAN compresses Traffic Class and Flow Label to a single bit when their values are both zero.
Each compressed form has reserved values that indicate that the fields are carried inline for use when they don’t match the elided case.
6LoWPAN elides other fields by exploiting cross-layer redundancy.
It can derive Payload Length – which is always elided – from the 802.15.4 frame or 6LoWPAN fragmentation header.
The 64-bit interface identifier (IID) for both source and destination addresses are elided if the destination can derive them from the corresponding link-layer address in the 802.15.4 or mesh addressing header.
Finally, 6LoWPAN always elides Version by communicating via IPv6.

The HC1 encoding is shown in Figure 11.
The first byte is the dispatch byte and indicates the use of HC1.
Following the dispatch byte are 8 bits that identify how the IPv6 fields are compressed.
For each address,
	one bit is used to indicate if the IPv6 prefix is linklocal and elided and one bit is used to indicate if the IID can be derived from the IEEE 802.15.4 link address.
The TF bit indicates whether Traffic Class and Flow Label are both zero and elided.
The two Next Header bits indicate if the IPv6 Next Header value is 7UDP,
	TCP,
	or ICMP and compressed or carried inline.
The HC2 bit indicates if the next header is compressed using HC2.
Fully compressed,
	the HC1 encoding reduces the IPv6 header to three bytes,
	including the dispatch header.
Hops Left is the only field always carried inline.


RFC 4944 uses stateless compression techniques to reduce the overhead of UDP headers.
When the HC2 bit is set in the HC1 encoding,
	an additional 8-bits is included immediately following the HC1 encoding bits that specify how the UDP header is compressed.
To effectively compress UDP ports, 6LoWPAN introduces a range of wellknown ports (61616 – 61631).
When ports fall in the well-known range,
	the upper 12 bits may be elided.
If both ports fall within range,
	both Source and Destination ports are compressed down to a single byte.
HC2 also allows elision of the UDP Length,
	as it can be derived from the IPv6 Payload Length field.

The best-case compression efficiency occurs with link-local unicast communication,
	where HC1 and HC2 can compress a UDP/IPv6 header down to 7 bytes.
The Version,
	Traffic Class,
	Flow Label,
	Payload Length,
	Next Header,
	and linklocal prefixes for the IPv6 Source and Destination addresses are all elided.
The suffix for both IPv6 source and destination addresses are derived from the IEEE 802.15.4 header.

However,
	RFC 4944 does not efficiently compress headers when communicating outside of link-local scope or when using multicast.
Any prefix other than the linklocal prefix must be carried inline.
Any suffix must be at least 64 bits when carried inline even if derived from a short 802.15.4 address.
As shown in Figure 8,
	HC1/HC2 can compress a link-local multicast UDP/IPv6 header down to 23 bytes in the best case.
When communicating with nodes outside the LoWPAN,
	the IPv6 Source Address prefix and full IPv6 Destination Address must be carried inline.

\paragraph{Header compression Improved (draft-hui-6lowpan-hc-01)}

To provide better compression over a broader range of scenarios,
	the 6LoWPAN working group is standardizing an improved header compression encoding format,
	called HC.
The format defines a new encoding for compressing IPv6 header,
	called IPHC.
The new format allows Traffic Class and Flow Label to be individually compressed,
	Hop Limit compression when common values (E.g., 1 or 255) are used,
	makes use of shared-context to elide the prefix from IPv6 addresses,
	and supports multicast addresses most often used for IPv6 ND and SLAAC.
Contexts act as shared state for all nodes within the LoWPAN.
A single context holds a single prefix.
IPHC identifies the context using a 4-bit index,
	allowing IPHC to support up to 16 contexts simultaneously within the LoWPAN.
When an IPv6 address matches a context’s stored prefix,
	IPHC compresses the prefix to the context’s 4-bit identifier.
Note that contexts are not limited to prefixes assigned to the LoWPAN but can contain any arbitrary prefix.
As a result,
	share contexts can be configured such that LoWPAN nodes can compress the prefix in both Source and Destination addresses even when communicating with nodes outside the LoWPAN.

The improved header compression encoding is shown in Figure 8.
The first three bits (011) form the header type and indicate the use of IPHC.
The TF bits indicate whether the Traffic Class and/or Flow Label fields are compressed.
The HLIM bits indicate whether the Hop Limit takes the value 1 or 255 and compressed,
	or carried inline.

Bits 8-15 of the IPHC encoding indicate the compression methods used for the IPv6 Source and Destination Addresses.
When the Context Identifier (CID) bit is zero,
	the default context may be used to compress Source and/or Destination Addresses.
This mode is typically when both Source and Destination Addresses are assigned to nodes in the same LoWPAN.
When the CID bit is one,
	two additional 4-bit fields follow the IPHC encoding to indicate which one of 16 contexts is in use for the source and destination addresses.
The Source Address Compression (SAC) indicates whether stateless compression is used (typically for link-local communication) or stateful context-based compression is used (typically for global communication).
The Source Address Mode (SAM) indicates whether the full Source Address is carried inline,
	upper 16 or 64-bits are elided,
	or the full Source Address is elided.
When SAC is set and the Source Addresses’ prefix is elided,
	the identified context is used to restore those bits.
The Multicast (M) field indicates whether the Destination Address is a unicast or multicast address.
When the Destination Address is a unicast address,
	the DAC and DAM bits are analogous to the SAC and SAM bits.
When the Destination Address is a multicast address,
	the DAM bits indicate different forms of multicast compression.
HC also defines a new framework for compressing arbitrary next headers,
	called NHC.
HC2 in RFC 4944 is only capable of compressing UDP,
	TCP,
	and ICMPv6 headers,
	the latter two are not yet defined.
Instead,
	the NHC header defines a new variable length Next Header identifier,
	allowing for future definition of arbitrary next header compression encodings.
HC initially defines a compression encoding for UDP headers,
	similar to that defined in RFC 4944.
Like RFC 4944,
	HC utilizes the same well-known port range (61616-61631) to effectively compress UDP ports down to 4-bits each in the best case.
However,
	HC no longer provides an option to carry the Payload Length in line,
	as it can always be derived from the IPv6 header.
Finally,
	HC allows elision of the UDP Checksum whenever an 10upper layer message integrity check covers the same information and has at least the same strength.
Such a scenario is typical when transportor application-layer security is used.
As a result,
	the UDP header can be compressed down to two bytes in the best case.


% section protocols (end)
\begin{table}[h!]
\scriptsize
	\begin{tabulary}{\columnwidth}{L|L|L|L|L}
		\bf{Routing protocol}  & \bf{Control Cost} & \bf{Link Cost} & \bf{Node Cost} \\\hline
		\bf{OSPF/IS-IS}        & \ko               & \ok            & \ko      \\
		\bf{OLSRv2}            & ?                 & \ok            & \ok      \\
	%		\bf{TBRPF}             & \ko               & \ok            & ?        \\
		\bf{RIP}               & \ok               & ?              & \ko      \\
	%		\bf{AODV}              & \ok               & \ko            & \ko      \\
	%		\bf{DYMO}              & \ok               & ?              & ?        \\
		\bf{DSR}               & \ok               & \ko            & \ko      \\
		\bf{RPL}               & \ok               & \ok            & \ok      \\\hline
	\end{tabulary}
	\caption{\label{tab:routingsComaprson} Routing protocols comparison \cite{_rpl2_}}
\end{table}


\begin{itemize}
	\item Routing over low-power and lossy links (ROLL)
	\item Support minimal routing requirements.
	\begin{itemize}
		\item like multipoint-to-point, point-to-multipoint and point-to-point.
	\end{itemize}
	\item A Destination Oriented Directed Acyclic Graph (DODAG)
	\begin{itemize}
		\item Directed acyclic graph with a single root.
		\item Each node is aware of ts parents 
		\item but not about related children
	\end{itemize}
	\item RPL uses four types of control messages
	\begin{itemize}
		\item DODAG Information Object (DIO)
		\item Destination Advertisement Object (DAO)
		\item DODAG Information Solicitation (DIS)
		\item DAO Acknowledgment (DAO-ACk)
	\end{itemize}
	%				\item RPL routers work under one of two modes:
	%					\begin{itemize}
	%						\item Non-Storing mode
	%						\item Storing modes mode
	%					\end{itemize}
\end{itemize}


\begin{itemize}
	\item Standard topologies to form IEEE 802.15.4e networks are 
	\begin{itemize}
		\item[Star] contains at least one FFD and some RFDs
		\item[Mesh] contains a PAN coordinator and other nodes communicate with each other
		\item[Cluster] consists of a PAN coordinator, a cluster head and normal nodes.
	\end{itemize}
	\item The IEEE 802.15.4e standard supports 2 types of network nodes
	\begin{itemize}
		\item[FFD] Full function device: serve as a coordinator
		\begin{itemize}
			\item It is responsible for creation, control and maintenance of the net
			\item It store a routing table in their memory and implement a full MAC
		\end{itemize}
		\item[RFD] Reduced function devices: simple nodes with restricted resources
		\begin{itemize}
			\item They can only communicate with a coordinator
			\item They are limited to a star topology
		\end{itemize}
	\end{itemize}
\end{itemize}

\begin{table}[h!]
\scriptsize
	\begin{tabulary}{\columnwidth}{L|L|L|L|L}
		\bf{Routing protocol}  & \bf{Control Cost} & \bf{Link Cost} & \bf{Node Cost} \\\hline
		\bf{OSPF/IS-IS}        & \ko               & \ok            & \ko      \\
		\bf{OLSRv2}            & ?                 & \ok            & \ok      \\
	%		\bf{TBRPF}             & \ko               & \ok            & ?        \\
		\bf{RIP}               & \ok               & ?              & \ko      \\
	%		\bf{AODV}              & \ok               & \ko            & \ko      \\
	%		\bf{DYMO}              & \ok               & ?              & ?        \\
		\bf{DSR}               & \ok               & \ko            & \ko      \\
		\bf{RPL}               & \ok               & \ok            & \ok      \\\hline
	\end{tabulary}
	\caption{\label{tab:routingsComaprison} Routing protocols comparison \cite{_rpl2_}}
\end{table}






\subsection{MAC}

\begin{table}[h!]
\scriptsize
	\begin{tabulary}{\columnwidth}{L|L|L|L|L}
	Channel based & FDMA                          & OFDMA WDMA SC-FDMA                              &  & \\\hline
	\             & TDMA                          & MF-TDMA STDMA                                   &  & \\\hline
	\             & CDMA                          & W-CDMA TD-CDMA TD-SCDMA DS-CDMA FH-CDMA MC-CDMA &  & \\\hline
	\             & SDMA                          & HC-SDMA                                         &  & \\\hline                                               &  & \\\hline
	Packet-based  & Collision recovery            & ALOHA Slotted ALOHA R-ALOHA AX.25 CSMA/CD       &  & \\\hline
	\             & Collision avoidance           & MACA MACAW CSMA CSMA/CA DCF PCF HCF CSMA/CARP   &  & \\\hline
	\             & Collision-free                & Token ring Token bus MS-ALOHA                   &  & \\\hline
	Duplexing methods  & Delay and disruption tolerant & MANET VANET DTN Dynamic Source Routing          &  & \\\hline

	\end{tabulary}
\caption{\label{tab:} }
\end{table}

\subsubsection{Sharing the channel}
\paragraph{TDMA, FDMA, CDMA, TSMA}

\subsubsection{Transmitting information}
\paragraph{TFDM, TDSSS, TFHSS}

\subsection{Radio}


\subsubsection{Digital modulation}
\paragraph{ASK, APSK, CPM, FSK, MFSK, MSK, OOK, PPM, PSK, QAM, SC-FDE, TCM WDM}

\subsubsection{Hierarchical modulation}
\paragraph{QAM, WDM} 

\subsubsection{Spread spectrum}
\paragraph{SS, DSSS, FHSS, THSS}

\subsubsection{Radio performance}

\paragraph{Power Level (dB)}

The dB measures the power of a signal as a function of its ratio to another standardized value. The
abbreviation dB is often combined with other abbreviations to represent the values that are compared.
Here are two examples:
\Itemize{
	\item dBm—The dB value is compared to 1 mW.
	\item dBw—The dB value is compared to 1 W.
}

\Equation{power}{Power (in dB) = 10 * log(10) (Signal/Reference)}

Where:
\Itemize{
	\item log(10) is logarithm base 10.
	\item Signal is the power of the signal.
	\item Reference is the reference power.
}

For example, if you want to calculate the power in dB of 50 mW:

Power (in dB) = 10 * log(10) (50/1) = 10 * 1.7 = 17 dBm

\paragraph{Receive Signal Strength Indicator RSSI}

Receiver sensitivity is defined as the minimum signal power level with an acceptable Bit Error Rate (in dBm or mW) that is necessary for the receiver to accurately decode a given signal.
This is usually expressed in a negative number depending on the data rate.
For example an Access Point may require an RSSI of at least negative -91 dBm at 1 MB and an even higher strength RF power -79 dBm to decode 54 MB.

\paragraph{Signal to Noise Ratio SNR}

Noise is any signal that interferes with your signal.
Noise can be due to other wireless devices such as cordless phones,
	microwave devices,
	etc.
This value is measured in decibels from 0 (zero) to -120 (minus 120).
Noise level is the amount of interference in your wireless signal,
	so lower is generally good for WLAN deployments.
Typical environments range between -90dBm and -98dBm with little ambient noise.
This value may be even higher if there is a lot of RF interference coming in from other non-802.11 devices on the same spectrum Signal to Noise Ratio or SNR is defined as the ratio of the transmitted power from the AP to the ambient (noise floor) energy present.
To calculate the SNR value,
	we add the Signal Value to the Noise Value to get the SNR ratio.
A positive value of the SNR ratio is always better.
For example,
	say your Signal value is -55dBm and your Noise value is -95dBm.
The difference of Signal (-55dBm) + Noise (-95dBm) = 40db—This means you have an SNR of 40.
Note that in the above equation you are not merely adding two numbers,
	but are interested in the “difference” between the Signal and Noise values,
	which is usually a positive number.
The lower the number,
	the lower the difference between noise and transmitted power,
	which in turn means lower quality of signal.
The higher the difference between Signal and Noise means that the transmitted signal is of much higher power than the noise floor,
	thereby making it easier for a WLAN client to decode the signal.


\paragraph{Signal Attenuation}

Signal attenuation or signal loss occurs even as the signal passes through air.
The loss of signal strength is more pronounced as the signal passes through different objects.
A transmit power of 20 mW is equivalent to 13 dBm.
Therefore if the transmitted power at the entry point of a plasterboard wall is at 13 dBm,
	the signal strength will be reduced to 10 dBm when exiting that wall.
Some common examples are shown in Table 10-5.



\subsection{Summary and discussion}
